import { Octokit } from "@octokit/rest";

export default async function (context, req) {
  const GITHUB_ORG = "Cloudfellas";
  const REPO_NAME = "pimv2-backend";
  const BRANCH_PREFIX = "role-assignment-";

  const GITHUB_PAT = process.env.GITHUB_PAT;
  if (!GITHUB_PAT) {
    console.error("‚ùå ERROR: GITHUB_PAT is missing!");
    context.res = {
      status: 500,
      body: "Error: GitHub PAT is missing in Azure Function settings.",
    };
    return;
  }

  console.log("‚úÖ GITHUB_PAT is loaded successfully.");
  const octokit = new Octokit({ auth: GITHUB_PAT });

  let payload = req.body;
  if (!Array.isArray(payload)) {
    context.res = { status: 400, body: "Invalid JSON payload. Expected an array." };
    return;
  }

  let changesMade = false;

  for (const assignment of payload) {
    const { Scope, Role, Groups, AssignmentType = "Permanent" } = assignment; // Default to "Permanent"
    const { SubscriptionId, ResourceGroupName, ResourceName } = Scope;

    // ‚úÖ Determine correct folder structure
    let folderPath = `assignments/${SubscriptionId}`;
    if (ResourceGroupName) {
      folderPath += `/${ResourceGroupName}`;
    }
    if (ResourceName) {
      folderPath += `/${ResourceName}`;
    }

    // ‚úÖ Determine correct file based on Assignment Type
    let assignmentFile = AssignmentType === "PIM" ? "roleassignments_PIM.json" : "roleassignments_permanent.json";
    const filePath = `${folderPath}/${assignmentFile}`;

    let existingData = { Assignments: [] };

    // ‚úÖ Ensure folder structure exists
    async function ensureFolderExists(path) {
      try {
        await octokit.repos.getContent({
          owner: GITHUB_ORG,
          repo: REPO_NAME,
          path,
        });
      } catch (error) {
        if (error.status === 404) {
          console.log(`üîπ Creating folder: ${path}`);
          await octokit.repos.createOrUpdateFileContents({
            owner: GITHUB_ORG,
            repo: REPO_NAME,
            path: `${path}/.keep`, // Create a hidden file to ensure folder exists
            message: `Create folder ${path}`,
            content: Buffer.from("").toString("base64"),
            branch: "main",
          });
        } else {
          throw error;
        }
      }
    }

    // üîß Ensure parent folders exist
    await ensureFolderExists(`assignments/${SubscriptionId}`);
    if (ResourceGroupName) {
      await ensureFolderExists(`assignments/${SubscriptionId}/${ResourceGroupName}`);
    }
    if (ResourceName) {
      await ensureFolderExists(folderPath);
    }

    // ‚úÖ Load existing assignments if they exist
    try {
      const { data: existingFile } = await octokit.repos.getContent({
        owner: GITHUB_ORG,
        repo: REPO_NAME,
        path: filePath,
      });

      existingData = JSON.parse(Buffer.from(existingFile.content, "base64").toString("utf-8"));
    } catch (error) {
      if (error.status !== 404) {
        console.error("‚ùå Error fetching existing file:", error.message);
        context.res = { status: 500, body: "Error fetching existing assignments." };
        return;
      }
      console.log(`üîπ No existing assignments found for ${filePath}, creating new.`);
    }

    // ‚úÖ Prevent Duplicate Assignments & Merge Groups
    function mergeAssignments(existingData, newAssignment) {
      const { Role, Groups } = newAssignment;

      // Find if a role already exists
      let existingAssignment = existingData.Assignments.find((entry) => entry.Role === Role);

      if (existingAssignment) {
        console.log(`üîπ Merging groups into existing assignment for Role: ${Role}`);

        // Merge the groups (remove duplicates)
        existingAssignment.Groups = Array.from(new Set([...existingAssignment.Groups, ...Groups]));
        return false; // No need for PR if merging existing data
      } else {
        console.log(`‚úÖ New assignment detected, adding to list.`);
        existingData.Assignments.push(newAssignment);
        return true;
      }
    }

    let isNewAssignment = mergeAssignments(existingData, { Role, Groups });
    if (!isNewAssignment) {
      console.log(`‚ÑπÔ∏è Assignment already exists. Skipping PR.`);
      continue;
    }

    // ‚úÖ Save Changes
    const fileContent = Buffer.from(JSON.stringify(existingData, null, 4)).toString("base64");

    try {
      console.log("üîπ Creating PR with GitHub API...");

      const { data: repoData } = await octokit.repos.get({
        owner: GITHUB_ORG,
        repo: REPO_NAME,
      });
      const defaultBranch = repoData.default_branch;

      const { data: mainBranch } = await octokit.repos.getBranch({
        owner: GITHUB_ORG,
        repo: REPO_NAME,
        branch: defaultBranch,
      });
      const mainBranchSHA = mainBranch.commit.sha;

      const branchName = `${BRANCH_PREFIX}${Date.now()}`;
      await octokit.git.createRef({
        owner: GITHUB_ORG,
        repo: REPO_NAME,
        ref: `refs/heads/${branchName}`,
        sha: mainBranchSHA,
      });

      // Check if file exists
      let fileSha = null;
      try {
        const { data: existingFile } = await octokit.repos.getContent({
          owner: GITHUB_ORG,
          repo: REPO_NAME,
          path: filePath,
          ref: branchName,
        });
        fileSha = existingFile.sha;
      } catch (error) {
        if (error.status !== 404) throw error;
      }

      // ‚úÖ Commit changes
      await octokit.repos.createOrUpdateFileContents({
        owner: GITHUB_ORG,
        repo: REPO_NAME,
        path: filePath,
        message: `Update ${AssignmentType} role assignments for ${filePath}`,
        content: fileContent,
        branch: branchName,
        ...(fileSha ? { sha: fileSha } : {}),
      });

      // ‚úÖ Create PR
      const prTitle = `Updated ${AssignmentType} Role Assignments for ${filePath}`;
      const prBody = `This PR updates **${AssignmentType}** assignments in **${filePath}**.\n\nChanges:\n- Role assignments modified or added.`;

      const { data: pr } = await octokit.pulls.create({
        owner: GITHUB_ORG,
        repo: REPO_NAME,
        title: prTitle,
        head: branchName,
        base: defaultBranch,
        body: prBody,
      });

      console.log("‚úÖ PR Created:", pr.html_url);
      changesMade = true;
    } catch (error) {
      console.error("‚ùå GitHub API Error:", error.response?.data || error.message);
      context.res = {
        status: 500,
        body: `GitHub API Error: ${error.response?.data?.message || error.message}`,
      };
      return;
    }
  }

  if (!changesMade) {
    context.res = {
      status: 200,
      body: { message: "No changes detected, PR skipped." },
    };
  }
}
